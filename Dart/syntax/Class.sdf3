module Class

imports

  Common
  lexical/Operator
  Metadata
  Type
  Expression
  Modifier
  Statement
  Parameters
  Function
  Arguments
  
context-free syntax // Class
  
  Class.Class = <<Metadata> <ABSTRACT?> class <ID> <TypeParameters?> <Parent?> <Mixins?> <Interfaces?> {
    <{ClassMember "\n"}*>
  }>
  
  Class.MixinApplication = <<Metadata> <ABSTRACT?> class <ID> <TypeParameters?> =
  	<Type> with <{Type ", "}+> <Interfaces?>;>
  
  Parent.Parent = <extends <Type>>
  
  Mixins.Mixins = <with <{Type ", "}+>>
  
  Interfaces.Interfaces = <implements <{Type ", "}+>>
  
context-free syntax // Class member definitions
	
	ClassMember.InitializedConstructor = <<Qualified><Parameters> : <{SuperCallOrFieldInitializer ", "}+> <FunctionBody>>
	
  ClassMember.ConstructorDeclaration = <<CONST?> <Qualified><Parameters> <RedirectionOrInitializers?>;>
  
  ClassMember.FactoryMethod = <factory <Qualified><Parameters> <FunctionBody>>
  
  ClassMember.OperatorMethod = <<Type?> operator <Operator><Parameters> <FunctionBody>>
  
  ClassMember.Method = <<STATIC?> <FunctionSignature> <FunctionBody>>
  
  ClassMember.Getter = <<STATIC?> <Type?> get <ID> <FunctionBody>>
  
  ClassMember.Setter = <<STATIC?> <Type?> set <ID><Parameters> <FunctionBody>>
  
  ClassMember.OperatorDeclaration = <<EXTERNAL?> <Type?> operator <Operator><Parameters>;>
  
  // TODO: Prettify AST/overlaps
  ClassMember.StaticFinalDeclaration = <static <FinalOrConst> <Type?> <{StaticFinalDeclaration ", "}+>;>
  
  ClassMember.FinalFieldDeclaration = <final <Type?> <{InitializedIdentifier ", "}+>;>
  
  ClassMember.StaticFieldDeclaration = <<STATIC?> <VarOrType> <{InitializedIdentifier ", "}+>;>
  
  ClassMember.FunctionDeclaration = <<FunctionModifier?> <FunctionSignature>;>
  
  FunctionModifier.FunctionModifier = <<EXTERNAL> <STATIC?>>
  
  
  RedirectionOrInitializers.Redirection = <: this<Arguments>>
  RedirectionOrInitializers.RedirectionMethod = <: this.<ID><Arguments>>
  RedirectionOrInitializers.Initializer = <: <{SuperCallOrFieldInitializer ", "}+>>
  
	// TODO: <Expression> should be <ConditionalExpression> and there should be <CascadeSelection*> after <Expression>
	SuperCallOrFieldInitializer = <super<Arguments>>
	SuperCallOrFieldInitializer = <super.<ID><Arguments>>
	SuperCallOrFieldInitializer = <<ID> = <Expression>>
	SuperCallOrFieldInitializer = <this.<ID> = <Expression>>

  StaticFinalDeclaration = <<ID> = <Expression>>
  
	InitializedIdentifier = <<ID> = <Expression>>
	InitializedIdentifier = <<ID>>
	
	FinalOrConst = "final"
	FinalOrConst = "const"
	
	VarOrType = "var"
	VarOrType = Type
  
context-free syntax // Rejections
  
  // Reject classes that have a mixin without parent
  Class = <<Metadata> <ABSTRACT?> class <ID> <TypeParameters?> <Mixins> <Interfaces?> {
    <{ClassMember "\n"}*>
  }> {reject}
  
template options

  keyword -/- [a-zA-Z]
  tokenize: ".("
